<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .tool-btn.active-tool {
            background-color: #dbeafe; /* light blue */
            color: #1e40af; /* dark blue */
        }
        /* Hide the default cursor over the canvas and show our custom one */
        #whiteboard-canvas {
            cursor: none;
        }
        #custom-cursor {
            position: absolute;
            border-radius: 50%;
            border: 1px solid #333;
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            transform: translate(-50%, -50%);
            transition: width 0.05s ease-out, height 0.05s ease-out;
            z-index: 1000;
        }
    </style>
</head>
<body class="bg-gray-100 m-0 p-0 overflow-hidden">
    <div class="relative w-screen h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-md p-3 flex justify-between items-center z-20">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">Collaborative Whiteboard</h1>
            <div class="text-right">
                <p class="font-semibold text-gray-700">Next wipe in:</p>
                <p id="countdown-timer" class="text-lg font-mono text-blue-600">--:--:--</p>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 relative">
            <canvas id="whiteboard-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            <div id="custom-cursor" class="hidden"></div>
        </main>

        <!-- Toolbar -->
        <div id="toolbar" class="absolute top-20 left-1/2 -translate-x-1/2 bg-white p-2 rounded-lg shadow-lg flex items-center space-x-2 z-20">
            <!-- Tools -->
            <button id="pencil" class="tool-btn active-tool p-2 rounded-md hover:bg-gray-200" title="Pencil">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>
            </button>
            <button id="eraser" class="tool-btn p-2 rounded-md hover:bg-gray-200" title="Eraser">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eraser"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21H7Z"/><path d="M22 21H7"/><path d="m5 12 5 5"/></svg>
            </button>
             <button id="dropper" class="tool-btn p-2 rounded-md hover:bg-gray-200" title="Color Dropper">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pipette"><path d="m2 22 1-1h3l9-9"/><path d="M3 21v-3l9-9"/><path d="m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.4.4c.9.9.9 2.5 0 3.4l-2.1 2.1c-.9.9-2.5.9-3.4 0L9 11.3c-.9-.9-.9-2.5 0-3.4L11.6 5.2c.9-.9 2.5-.9 3.4 0Z"/></svg>
            </button>
            <div class="h-8 w-px bg-gray-300"></div>
            <button id="undo-btn" class="tool-btn p-2 rounded-md hover:bg-gray-200" title="Undo">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-undo-2"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>
             <button id="redo-btn" class="tool-btn p-2 rounded-md hover:bg-gray-200" title="Redo">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-redo-2"><path d="m15 14 5-5-5-5"/><path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/></svg>
            </button>

            <!-- Color Picker -->
            <div class="h-8 w-px bg-gray-300"></div>
            <input type="color" id="color-picker" class="w-10 h-10 rounded-md border-none p-1 bg-clip-content" value="#000000" title="Color Picker">

            <!-- Size Slider -->
            <div class="h-8 w-px bg-gray-300"></div>
            <div class="flex items-center space-x-2 px-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-dot"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="1"/></svg>
                <input type="range" id="size-slider" min="1" max="100" value="5" class="w-32" title="Brush Size">
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="absolute bottom-4 right-4 flex flex-col space-y-2 z-20">
             <button id="view-boards-btn" class="bg-blue-500 text-white p-3 rounded-full shadow-lg hover:bg-blue-600 transition-colors" title="View Previous Boards">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-history"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <button id="download-btn" class="bg-green-500 text-white p-3 rounded-full shadow-lg hover:bg-green-600 transition-colors" title="Download as PNG">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
            </button>
        </div>

        <!-- Previous Boards Modal -->
        <div id="boards-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="p-4 border-b flex justify-between items-center">
                    <h2 class="text-xl font-bold">Previous Whiteboards</h2>
                    <button id="close-modal-btn" class="p-2 rounded-full hover:bg-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                    </button>
                </div>
                <div id="boards-list" class="p-4 overflow-y-auto">
                    <!-- List of previous boards will be injected here -->
                    <p id="loading-boards-msg">Loading history...</p>
                </div>
                 <div class="p-4 border-t text-center">
                    <p class="text-sm text-gray-500">Showing boards that have at least one drawing.</p>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- Firebase Setup ---
        // IMPORTANT: Replace this with your own Firebase project configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAsWvL3G607sa0igxV3ZQwElqR9GRUY5xc",
            authDomain: "monetization-board.firebaseapp.com",
            projectId: "monetization-board",
            storageBucket: "monetization-board.firebasestorage.app",
            messagingSenderId: "500162021745",
            appId: "1:500162021745:web:bf31a455ebc1b3089b4ed0"
        };
        
        // This __app_id is a placeholder. For real-time collaboration, you would
        // dynamically set this or use a single, hardcoded one for all users.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-collaborative-whiteboard';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, doc, updateDoc, getDocs, where, orderBy, limit, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getStorage, ref, listAll, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        
        // --- App State ---
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let brushColor = '#000000';
        let brushSize = 5;
        let currentTool = 'pencil'; // 'pencil', 'eraser', 'dropper'
        let userId = null;
        let allDrawingActions = []; // Local cache of all drawing data
        let currentStrokeId = null; // To group drawing segments into a single stroke

        // --- DOM Elements ---
        const canvas = document.getElementById('whiteboard-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const countdownTimer = document.getElementById('countdown-timer');
        const colorPicker = document.getElementById('color-picker');
        const sizeSlider = document.getElementById('size-slider');
        const pencilBtn = document.getElementById('pencil');
        const eraserBtn = document.getElementById('eraser');
        const dropperBtn = document.getElementById('dropper');
        const downloadBtn = document.getElementById('download-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const customCursor = document.getElementById('custom-cursor');
        
        // Modal elements
        const viewBoardsBtn = document.getElementById('view-boards-btn');
        const boardsModal = document.getElementById('boards-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const boardsList = document.getElementById('boards-list');
        const loadingBoardsMsg = document.getElementById('loading-boards-msg');

        // --- Firebase Refs ---
        const drawingActionsRef = collection(db, `artifacts/${appId}/public/data/drawingActions`);
        const cursorPositionsRef = collection(db, `artifacts/${appId}/public/data/cursorPositions`);
        const previousBoardsRef = ref(storage, `artifacts/${appId}/previous_boards`);

        // --- Functions ---

        const resizeCanvas = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            drawCanvas(); // Redraw canvas content after resize
        };

        const drawCanvas = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const visibleActions = allDrawingActions.filter(action => !action.undone);
            
            visibleActions.forEach(action => {
                ctx.beginPath();
                ctx.moveTo(action.startX, action.startY);
                ctx.lineTo(action.endX, action.endY);
                ctx.strokeStyle = action.color;
                ctx.lineWidth = action.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            });
        };
        
        const updateCursorPreview = () => {
            if (!customCursor) return;
            customCursor.style.width = `${brushSize}px`;
            customCursor.style.height = `${brushSize}px`;
            customCursor.style.borderColor = currentTool === 'eraser' ? '#ff0000' : '#333';
        };

        const draw = (e) => {
            if (!isDrawing || !currentStrokeId) return;
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const color = currentTool === 'eraser' ? '#f1f5f9' : brushColor;

            const action = {
                startX: lastX,
                startY: lastY,
                endX: currentX,
                endY: currentY,
                color: color,
                size: brushSize,
                timestamp: Date.now(),
                userId: userId,
                undone: false,
                strokeId: currentStrokeId, // Add the stroke ID to group segments
            };

            addDoc(drawingActionsRef, action);

            lastX = currentX;
            lastY = currentY;
        };

        const setActiveTool = (tool) => {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active-tool'));
            
            if (tool === 'pencil') pencilBtn.classList.add('active-tool');
            else if (tool === 'eraser') eraserBtn.classList.add('active-tool');
            else if (tool === 'dropper') dropperBtn.classList.add('active-tool');

            updateCursorPreview();
        };

        const handleUndo = async () => {
            if (!userId) return;
            
            // Find the last visible action segment for the current user to identify the stroke
            const userActions = allDrawingActions
                .filter(action => action.userId === userId && !action.undone)
                .sort((a, b) => b.timestamp - a.timestamp);

            if (userActions.length > 0) {
                const lastStrokeId = userActions[0].strokeId;
                if (!lastStrokeId) return; // Should not happen with new code

                // Find all segments belonging to that stroke
                const actionsToUndo = allDrawingActions.filter(action => action.strokeId === lastStrokeId);

                // Use a batch write to update all segments of the stroke at once
                const batch = writeBatch(db);
                actionsToUndo.forEach(action => {
                    const docRef = doc(db, `artifacts/${appId}/public/data/drawingActions`, action.id);
                    batch.update(docRef, { undone: true });
                });
                await batch.commit();
            }
        };

        const handleRedo = async () => {
            if (!userId) return;
            
            // Find the most recently undone action to identify the stroke to redo
            const undoneUserActions = allDrawingActions
                .filter(action => action.userId === userId && action.undone)
                .sort((a, b) => b.timestamp - a.timestamp);

            if (undoneUserActions.length > 0) {
                const strokeToRedoId = undoneUserActions[0].strokeId;
                if (!strokeToRedoId) return;

                // Find all segments belonging to that stroke
                const actionsToRedo = allDrawingActions.filter(action => action.strokeId === strokeToRedoId);

                // Use a batch write to update all segments at once
                const batch = writeBatch(db);
                actionsToRedo.forEach(action => {
                    const docRef = doc(db, `artifacts/${appId}/public/data/drawingActions`, action.id);
                    batch.update(docRef, { undone: false });
                });
                await batch.commit();
            }
        };
        
        const startDropper = () => {
            const dropperListener = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pixel = ctx.getImageData(x * window.devicePixelRatio, y * window.devicePixelRatio, 1, 1).data;
                const hexColor = `#${("000000" + ((pixel[0] << 16) | (pixel[1] << 8) | pixel[2]).toString(16)).slice(-6)}`;
                
                brushColor = hexColor;
                colorPicker.value = hexColor;
                
                canvas.removeEventListener('click', dropperListener);
                setActiveTool('pencil');
            };
            canvas.addEventListener('click', dropperListener);
        };

        const updateCountdown = () => {
            const now = new Date();
            const almatyOffset = 6 * 60 * 60 * 1000;
            const nowAlmaty = new Date(now.getTime() + now.getTimezoneOffset() * 60 * 1000 + almatyOffset);

            const tomorrowAlmaty = new Date(nowAlmaty);
            tomorrowAlmaty.setDate(tomorrowAlmaty.getDate() + 1);
            tomorrowAlmaty.setHours(6, 0, 0, 0);

            let diff = tomorrowAlmaty - nowAlmaty;
            if (nowAlmaty.getHours() >= 6) {
                // It's past 6 AM, countdown to tomorrow
            } else {
                 // It's before 6 AM, countdown to today's 6 AM
                const todayAlmaty = new Date(nowAlmaty);
                todayAlmaty.setHours(6, 0, 0, 0);
                diff = todayAlmaty - nowAlmaty;
            }

            const hours = Math.floor(diff / (1000 * 60 * 60)).toString().padStart(2, '0');
            const minutes = Math.floor((diff / (1000 * 60)) % 60).toString().padStart(2, '0');
            const seconds = Math.floor((diff / 1000) % 60).toString().padStart(2, '0');
            countdownTimer.textContent = `${hours}:${minutes}:${seconds}`;
        };

        const showPreviousBoards = async () => {
            boardsModal.classList.remove('hidden');
            loadingBoardsMsg.textContent = 'Loading history...';
            boardsList.innerHTML = '';
            boardsList.appendChild(loadingBoardsMsg);

            try {
                const res = await listAll(previousBoardsRef);
                if (res.items.length === 0) {
                    loadingBoardsMsg.textContent = 'No previous boards have been saved yet.';
                    return;
                }
                
                loadingBoardsMsg.remove();
                const sortedItems = res.items.sort((a,b) => b.name.localeCompare(a.name));

                for (const itemRef of sortedItems) {
                    const url = await getDownloadURL(itemRef);
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data && data.length > 0) {
                        const dateString = itemRef.name.replace('.json', '');
                        const boardContainer = document.createElement('div');
                        boardContainer.className = 'mb-6 p-4 border rounded-lg';
                        
                        const title = document.createElement('h3');
                        title.className = 'text-lg font-bold mb-2';
                        title.textContent = `Board from: ${dateString}`;
                        
                        const previewCanvas = document.createElement('canvas');
                        previewCanvas.className = 'w-full h-auto bg-gray-50 rounded-md aspect-video';
                        
                        boardContainer.appendChild(title);
                        boardContainer.appendChild(previewCanvas);
                        boardsList.appendChild(boardContainer);

                        // Render the preview
                        setTimeout(() => {
                           const prevCtx = previewCanvas.getContext('2d');
                           const dpr = window.devicePixelRatio || 1;
                           const rect = previewCanvas.getBoundingClientRect();
                           previewCanvas.width = rect.width * dpr;
                           previewCanvas.height = rect.height * dpr;
                           prevCtx.scale(dpr, dpr);
                           
                           data.forEach(action => {
                               prevCtx.beginPath();
                               prevCtx.moveTo(action.startX * (rect.width / canvas.clientWidth), action.startY * (rect.height / canvas.clientHeight));
                               prevCtx.lineTo(action.endX * (rect.width / canvas.clientWidth), action.endY * (rect.height / canvas.clientHeight));
                               prevCtx.strokeStyle = action.color;
                               prevCtx.lineWidth = action.size;
                               prevCtx.lineCap = 'round';
                               prevCtx.lineJoin = 'round';
                               prevCtx.stroke();
                           });
                        }, 100);
                    }
                }
            } catch (error) {
                console.error("Error loading previous boards:", error);
                loadingBoardsMsg.textContent = 'Could not load board history.';
            }
        };

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            // Generate a unique ID for this new stroke
            currentStrokeId = `${userId}-${Date.now()}`;
            const rect = canvas.getBoundingClientRect();
            [lastX, lastY] = [e.clientX - rect.left, e.clientY - rect.top];
        });
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            currentStrokeId = null; // End the current stroke
        });
        canvas.addEventListener('mouseout', () => {
            isDrawing = false;
            currentStrokeId = null; // Also end stroke if mouse leaves canvas
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        // Toolbar events
        colorPicker.addEventListener('input', (e) => brushColor = e.target.value);
        sizeSlider.addEventListener('input', (e) => {
            brushSize = e.target.value;
            updateCursorPreview();
        });
        pencilBtn.addEventListener('click', () => setActiveTool('pencil'));
        eraserBtn.addEventListener('click', () => setActiveTool('eraser'));
        dropperBtn.addEventListener('click', () => {
             setActiveTool('dropper');
             startDropper();
        });
        
        undoBtn.addEventListener('click', handleUndo);
        redoBtn.addEventListener('click', handleRedo);

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.clientWidth;
            tempCanvas.height = canvas.clientHeight;
            tempCtx.fillStyle = '#f1f5f9'; // bg-slate-100
            tempCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);

            link.download = 'whiteboard.png';
            link.href = tempCanvas.toDataURL();
            link.click();
        });
        
        // Modal events
        viewBoardsBtn.addEventListener('click', showPreviousBoards);
        closeModalBtn.addEventListener('click', () => boardsModal.classList.add('hidden'));

        // Custom cursor events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            customCursor.style.left = `${e.clientX - rect.left}px`;
            customCursor.style.top = `${e.clientY - rect.top}px`;
        });
        canvas.addEventListener('mouseenter', () => customCursor.classList.remove('hidden'));
        canvas.addEventListener('mouseleave', () => customCursor.classList.add('hidden'));

        // --- Initialization ---
        
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                // Subscribe to drawing actions
                onSnapshot(query(drawingActionsRef, orderBy("timestamp")), (snapshot) => {
                    allDrawingActions = [];
                    snapshot.forEach(doc => {
                        allDrawingActions.push({ id: doc.id, ...doc.data() });
                    });
                    drawCanvas();
                });
            } else {
                await signInAnonymously(auth);
            }
        });

        resizeCanvas();
        updateCursorPreview();
        setInterval(updateCountdown, 1000);
        updateCountdown();
    </script>
</body>
</html>

